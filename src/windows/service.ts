#!/usr/bin/env bun

import { execSync } from "node:child_process";
import { existsSync, writeFileSync, mkdirSync } from "node:fs";
import { join, dirname } from "node:path";
import { homedir } from "node:os";

interface WindowsServiceConfig {
  name: string;
  displayName: string;
  description: string;
  executable: string;
  arguments: string[];
  workingDirectory: string;
  environment: Record<string, string>;
}

interface WindowsServiceStatus {
  name: string;
  state: 'running' | 'stopped' | 'paused' | 'starting' | 'stopping';
  startType: 'auto' | 'demand' | 'disabled';
  processId?: number;
  startTime?: Date;
  description?: string;
}

class WindowsServiceManager {
  private configPath: string;
  
  constructor() {
    this.configPath = join(homedir(), '.bs9', 'windows-services.json');
    this.ensureConfigDir();
  }
  
  private ensureConfigDir(): void {
    const configDir = dirname(this.configPath);
    if (!existsSync(configDir)) {
      mkdirSync(configDir, { recursive: true });
    }
  }
  
  private loadConfigs(): Record<string, WindowsServiceConfig> {
    try {
      if (existsSync(this.configPath)) {
        const content = require('fs').readFileSync(this.configPath, 'utf-8');
        return JSON.parse(content);
      }
    } catch (error) {
      console.warn('Failed to load Windows service configs:', error);
    }
    return {};
  }
  
  private saveConfigs(configs: Record<string, WindowsServiceConfig>): void {
    try {
      writeFileSync(this.configPath, JSON.stringify(configs, null, 2));
    } catch (error) {
      console.error('Failed to save Windows service configs:', error);
    }
  }
  
  private checkAdminPrivileges(): boolean {
    try {
      execSync('net session', { stdio: 'ignore' });
      return true;
    } catch {
      return false;
    }
  }
  
  private generateServiceScript(config: WindowsServiceConfig): string {
    const envVars = Object.entries(config.environment)
      .map(([key, value]) => `$env:${key}="${value}"`)
      .join('\n');
    
    const args = config.arguments.map(arg => `"${arg}"`).join(' ');
    
    return `# PowerShell script for BS9 Windows Service
# Generated by BS9 Service Manager

${envVars}

$serviceName = "${config.name}"
$displayName = "${config.displayName}"
$description = "${config.description}"
$executable = "${config.executable}"
$arguments = "${args}"
$workingDirectory = "${config.workingDirectory}"

# Check if service exists
$service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue

if (-not $service) {
    Write-Host "Creating Windows service: $serviceName"
    
    # Create service
    New-Service -Name $serviceName -DisplayName $displayName -Description $description -BinaryPathName "$executable $arguments" -StartupType Automatic -WorkingDirectory $workingDirectory
    
    Write-Host "Service created successfully"
} else {
    Write-Host "Service already exists: $serviceName"
}

# Configure service recovery
sc.exe failure $serviceName reset= 86400 actions= restart/5000/restart/10000/restart/20000

Write-Host "Service configuration completed"
`;
  }
  
  async createService(config: WindowsServiceConfig): Promise<void> {
    if (!this.checkAdminPrivileges()) {
      throw new Error('Administrator privileges required to create Windows services');
    }
    
    const configs = this.loadConfigs();
    configs[config.name] = config;
    this.saveConfigs(configs);
    
    // Generate PowerShell script
    const scriptPath = join(homedir(), '.bs9', `${config.name}-setup.ps1`);
    writeFileSync(scriptPath, this.generateServiceScript(config));
    
    try {
      // Execute PowerShell script
      execSync(`powershell -ExecutionPolicy Bypass -File "${scriptPath}"`, { stdio: 'inherit' });
      console.log(`‚úÖ Windows service '${config.name}' created successfully`);
    } catch (error) {
      console.error(`‚ùå Failed to create Windows service: ${error}`);
      throw error;
    }
  }
  
  async startService(serviceName: string): Promise<void> {
    if (!this.checkAdminPrivileges()) {
      throw new Error('Administrator privileges required to start Windows services');
    }
    
    try {
      execSync(`net start "${serviceName}"`, { stdio: 'inherit' });
      console.log(`‚úÖ Windows service '${serviceName}' started successfully`);
    } catch (error) {
      console.error(`‚ùå Failed to start Windows service: ${error}`);
      throw error;
    }
  }
  
  async stopService(serviceName: string): Promise<void> {
    if (!this.checkAdminPrivileges()) {
      throw new Error('Administrator privileges required to stop Windows services');
    }
    
    try {
      execSync(`net stop "${serviceName}"`, { stdio: 'inherit' });
      console.log(`‚úÖ Windows service '${serviceName}' stopped successfully`);
    } catch (error) {
      console.error(`‚ùå Failed to stop Windows service: ${error}`);
      throw error;
    }
  }
  
  async deleteService(serviceName: string): Promise<void> {
    if (!this.checkAdminPrivileges()) {
      throw new Error('Administrator privileges required to delete Windows services');
    }
    
    try {
      // Stop service first
      try {
        await this.stopService(serviceName);
      } catch {
        // Service might already be stopped
      }
      
      // Delete service
      execSync(`sc.exe delete "${serviceName}"`, { stdio: 'inherit' });
      
      // Remove from config
      const configs = this.loadConfigs();
      delete configs[serviceName];
      this.saveConfigs(configs);
      
      console.log(`‚úÖ Windows service '${serviceName}' deleted successfully`);
    } catch (error) {
      console.error(`‚ùå Failed to delete Windows service: ${error}`);
      throw error;
    }
  }
  
  async getServiceStatus(serviceName: string): Promise<WindowsServiceStatus | null> {
    try {
      const output = execSync(`sc.exe query "${serviceName}"`, { encoding: 'utf-8' });
      
      const status: WindowsServiceStatus = {
        name: serviceName,
        state: 'stopped',
        startType: 'demand'
      };
      
      // Parse output
      const lines = output.split('\n');
      for (const line of lines) {
        if (line.includes('STATE')) {
          if (line.includes('RUNNING')) status.state = 'running';
          else if (line.includes('STOPPED')) status.state = 'stopped';
          else if (line.includes('PAUSED')) status.state = 'paused';
          else if (line.includes('STARTING')) status.state = 'starting';
          else if (line.includes('STOPPING')) status.state = 'stopping';
        }
        if (line.includes('START_TYPE')) {
          if (line.includes('AUTO_START')) status.startType = 'auto';
          else if (line.includes('DEMAND_START')) status.startType = 'demand';
          else if (line.includes('DISABLED')) status.startType = 'disabled';
        }
      }
      
      return status;
    } catch (error) {
      return null;
    }
  }
  
  async listServices(): Promise<WindowsServiceStatus[]> {
    try {
      const configs = this.loadConfigs();
      const services: WindowsServiceStatus[] = [];
      
      for (const serviceName of Object.keys(configs)) {
        const status = await this.getServiceStatus(serviceName);
        if (status) {
          status.description = configs[serviceName].description;
          services.push(status);
        }
      }
      
      return services;
    } catch (error) {
      console.error('Failed to list Windows services:', error);
      return [];
    }
  }
  
  async enableAutoStart(serviceName: string): Promise<void> {
    if (!this.checkAdminPrivileges()) {
      throw new Error('Administrator privileges required to configure Windows services');
    }
    
    try {
      execSync(`sc.exe config "${serviceName}" start= auto`, { stdio: 'inherit' });
      console.log(`‚úÖ Windows service '${serviceName}' set to auto-start`);
    } catch (error) {
      console.error(`‚ùå Failed to configure auto-start: ${error}`);
      throw error;
    }
  }
  
  async disableAutoStart(serviceName: string): Promise<void> {
    if (!this.checkAdminPrivileges()) {
      throw new Error('Administrator privileges required to configure Windows services');
    }
    
    try {
      execSync(`sc.exe config "${serviceName}" start= demand`, { stdio: 'inherit' });
      console.log(`‚úÖ Windows service '${serviceName}' set to manual start`);
    } catch (error) {
      console.error(`‚ùå Failed to configure auto-start: ${error}`);
      throw error;
    }
  }
}

export async function windowsCommand(action: string, options: any): Promise<void> {
  console.log('ü™ü BS9 Windows Service Management');
  console.log('='.repeat(80));
  
  const manager = new WindowsServiceManager();
  
  try {
    switch (action) {
      case 'create':
        if (!options.name || !options.file) {
          console.error('‚ùå --name and --file are required for create action');
          process.exit(1);
        }
        
        const config: WindowsServiceConfig = {
          name: options.name,
          displayName: options.displayName || options.name,
          description: options.description || `BS9 Service: ${options.name}`,
          executable: options.file,
          arguments: options.args || [],
          workingDirectory: options.workingDir || process.cwd(),
          environment: options.env ? JSON.parse(options.env) : {}
        };
        
        await manager.createService(config);
        await manager.startService(options.name);
        break;
        
      case 'start':
        if (!options.name) {
          console.error('‚ùå --name is required for start action');
          process.exit(1);
        }
        await manager.startService(options.name);
        break;
        
      case 'stop':
        if (!options.name) {
          console.error('‚ùå --name is required for stop action');
          process.exit(1);
        }
        await manager.stopService(options.name);
        break;
        
      case 'restart':
        if (!options.name) {
          console.error('‚ùå --name is required for restart action');
          process.exit(1);
        }
        await manager.stopService(options.name);
        await manager.startService(options.name);
        break;
        
      case 'delete':
        if (!options.name) {
          console.error('‚ùå --name is required for delete action');
          process.exit(1);
        }
        await manager.deleteService(options.name);
        break;
        
      case 'status':
        if (options.name) {
          const status = await manager.getServiceStatus(options.name);
          if (status) {
            console.log(`üìä Service Status: ${status.name}`);
            console.log(`   State: ${status.state}`);
            console.log(`   Start Type: ${status.startType}`);
            if (status.description) console.log(`   Description: ${status.description}`);
          } else {
            console.log(`‚ùå Service '${options.name}' not found`);
          }
        } else {
          const services = await manager.listServices();
          console.log('üìã BS9 Windows Services:');
          console.log('-'.repeat(80));
          console.log('SERVICE'.padEnd(25) + 'STATE'.padEnd(15) + 'START TYPE'.padEnd(15) + 'DESCRIPTION');
          console.log('-'.repeat(80));
          
          for (const service of services) {
            console.log(
              service.name.padEnd(25) +
              service.state.padEnd(15) +
              service.startType.padEnd(15) +
              (service.description || '')
            );
          }
          
          if (services.length === 0) {
            console.log('No BS9 Windows services found.');
          }
        }
        break;
        
      case 'enable':
        if (!options.name) {
          console.error('‚ùå --name is required for enable action');
          process.exit(1);
        }
        await manager.enableAutoStart(options.name);
        break;
        
      case 'disable':
        if (!options.name) {
          console.error('‚ùå --name is required for disable action');
          process.exit(1);
        }
        await manager.disableAutoStart(options.name);
        break;
        
      default:
        console.error(`‚ùå Unknown action: ${action}`);
        console.log('Available actions: create, start, stop, restart, delete, status, enable, disable');
        process.exit(1);
    }
  } catch (error) {
    console.error(`‚ùå Failed to ${action} Windows service: ${error}`);
    process.exit(1);
  }
}
